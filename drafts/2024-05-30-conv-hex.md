---
layout: post
title: "Convolution with hexagonal kernels in `hexfft`"
author: "Chris Langfield"
categories: math
tags: [math]
---

In the last post I mentioned the [HexagDLy](https://github.com/ai4iacts/hexagdly) Python package, which implements convolution kernels in natively hexagonal coordinates for use in CNNs (based on PyTorch).

The codebase comes with a nifty way of generating examples, with pre-set patterns such as "snowflake" and "double_hexagon". I decided to test out frequency space convolutions in `hexfft`
using their most basic example, which can be found [here](https://github.com/ai4iacts/hexagdly/blob/master/notebooks/hexagdly_2d_example.ipynb). The `toy_data` method spits out hexagonal shapes
on grids with customizable sizes as Torch tensors, which can then be added together.

I found that the package uses an offset coordinate system which is perfectly compatible with `hexfft`'s "offset" `HexArray`s (provided we take the transpose), and wrote a tiny converter for the toy examples:

```python
from example_utils import toy_data # found in the HexagDLy repository
from hexfft import HexArray
import numpy as np

def toy_data_hexarray(*args, **kwargs):
    x = toy_data(*args, **kwargs)
    return HexArray(np.squeeze(np.array(x.to_torch_tensor().T)))
```

We can then generate the examples and load them as `HexArray`s:

```python
from hexfft.plot import hexshow

t1 = toy_data_hexarray('double_hex', num_rows, num_columns, channels, batch_size, px=5, py=5)
t2 = toy_data_hexarray('double_hex', num_rows, num_columns, channels, batch_size, px=14, py=8)
t3 = toy_data_hexarray('snowflake_3', num_rows, num_columns, channels, batch_size, px=5, py=16)
t4 = toy_data_hexarray('snowflake_3', num_rows, num_columns, channels, batch_size, px=14, py=19)

h = t1 + t2 + t3 + t4 

hexshow(h, cmap="gray_r")
```
![hexagdly_ex](https://github.com/chris-langfield/chris-langfield.github.io/assets/34426450/26f22407-8f1c-463d-baf9-37abe1702b79)

Note that we're displaying this rotated by 90 degrees since `HexagDLy` offsets columns rather than rows.

Now we can create the same smoothing kernel that they use as a `HexArray`:

```python
kernel = HexArray(np.zeros((num_rows, num_columns)))
c1, c2 = num_rows//2, num_columns//2
kernel[c1, c2] = 1.
idx = np.array([[c1, c2-1], [c1, c2+1], [c1-1, c2], [c1+1, c2], [c1-1, c2-1], [c1+1, c2-1]])
kernel[tuple(idx.T)] = 1.
hexshow(kernel, cmap="gray_r")
```
![kern](https://github.com/chris-langfield/chris-langfield.github.io/assets/34426450/24372aca-a975-424d-b5e1-5bc30963a1fa)

And then convolve via multiplication in the frequency domain:

```python
from hexfft import fft, ifft
from hexfft.utils import filter_shift

H = fft(h)
K = fft(filter_shift(kernel))

CONV = H * K
conv = ifft(CONV)
hexshow(np.real(conv), cmap="gray_r")
```

`hexfft` results:
![results](https://github.com/chris-langfield/chris-langfield.github.io/assets/34426450/7a7cbfdc-62bb-4ea9-9b3a-b51e79d3547b)

`hexagDLy` results:
![hdly_result](https://github.com/chris-langfield/chris-langfield.github.io/assets/34426450/603c2cc5-ff6f-4940-9354-ec6a578cf812)

